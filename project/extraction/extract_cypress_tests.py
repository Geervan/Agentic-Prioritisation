"""
extract_cypress_tests.py

Scans a local Cypress test suite (cypress/e2e/**/*.cy.js) and extracts simple
metadata per `it()` block with UI selectors.

Output is written to `data/small_testcases.json` as a list of dicts containing:
{
  "id": int,
  "name": str,
  "component": str,
  "ui_element": str,
  "selector": str,
  "execution_time": float,
  "last_result": str,
  "flaky": bool
}

This script is modular: the main functions can be imported and reused for
medium/large projects. It does not run automatically when imported.

Notes:
- The script uses regex heuristics to find `it(...)` blocks and `cy.get()`/
  `cy.contains()` selectors. It is robust to many common styles but does not
  attempt full JS parsing.
- Tests without any UI selectors are skipped.

"""
from __future__ import annotations

import argparse
import json
import logging
import random
import re
from pathlib import Path
from typing import Dict, Iterable, List, Optional, Tuple


logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO, format="%(levelname)s: %(message)s")


# ----------------------- Helper extraction functions -----------------------

def extract_selectors_from_js(js_text: str) -> List[str]:
    """Return a list of selector/text strings found in `cy.get()` and
    `cy.contains()` calls inside the given JS text.

    This uses conservative regexes to capture literal string arguments only
    (single/double/backtick quoted). It will ignore dynamic/template usages.
    """
    selectors: List[str] = []

    # Pattern to capture cy.get('...') or cy.get("...") or cy.get(`...`)
    get_pattern = re.compile(r"cy\.get\(\s*([\'\"`])(?P<sel>.*?)\1\s*\)", re.DOTALL)
    # Pattern to capture cy.contains('...') - often used for text selectors
    contains_pattern = re.compile(r"cy\.contains\(\s*([\'\"`])(?P<sel>.*?)\1\s*(?:,|\))", re.DOTALL)

    for m in get_pattern.finditer(js_text):
        sel = m.group("sel").strip()
        if sel:
            selectors.append(sel)

    for m in contains_pattern.finditer(js_text):
        sel = m.group("sel").strip()
        if sel:
            selectors.append(sel)

    # Deduplicate while preserving order
    seen = set()
    uniq = []
    for s in selectors:
        if s not in seen:
            uniq.append(s)
            seen.add(s)
    return uniq


def infer_ui_element(selector: str) -> str:
    """Infer a coarse UI element type from a selector or text.

    Returns one of: 'button', 'input', 'link', or 'unknown'.
    Heuristics are intentionally simple and conservative.
    """
    s = selector.lower()

    # If selector looks like an HTML tag
    tag_match = re.match(r"^\s*([a-z0-9]+)\b", s)
    if tag_match:
        tag = tag_match.group(1)
        if tag in ("button",):
            return "button"
        if tag in ("input", "textarea", "select"):
            return "input"
        if tag in ("a",):
            return "link"

    # Common attributes or keywords
    if "[type=submit" in s or "[type=button" in s or "button" in s or "btn" in s:
        return "button"
    if "input" in s or "[type=" in s or "textarea" in s or "select" in s:
        return "input"
    if "a[" in s or "href" in s or "link" in s or s.startswith("#") and "link" in s:
        return "link"

    # Text-based contains may indicate a button or link by word clues
    if re.search(r"\b(click|submit|confirm|save|delete)\b", s):
        return "button"
    if re.search(r"\b(link|open|visit|go to)\b", s):
        return "link"

    return "unknown"


def generate_last_result() -> str:
    """Return a last_result value ('pass' or 'fail').

    This small helper is separated so it can be replaced easily later.
    """
    return random.choice(["pass", "fail"])


def generate_synthetic_results() -> Tuple[float, str, bool]:
    """Generate execution_time, last_result and flaky flag.

    - execution_time: random float between 1.0 and 4.0
    - last_result: generated by `generate_last_result()`
    - flaky: True with 10% probability
    """
    execution_time = round(random.uniform(1.0, 4.0), 2)
    last_result = generate_last_result()
    flaky = random.random() < 0.10
    return execution_time, last_result, flaky


# ----------------------- Spec parsing and scanning -------------------------

def _find_it_blocks(js_text: str) -> Iterable[Tuple[str, str]]:
    """Yield tuples (it_name, block_text) by splitting the file at each `it(`.

    This is a heuristic: it locates the `it('name'` occurrences and returns
    the text from that occurrence up to the next `it(` (or EOF). This is
    resilient for common test styles and avoids attempting a full JS parse.
    """
    it_name_re = re.compile(r"it\(\s*([\'\"`])(?P<name>.*?)\1", re.DOTALL)
    matches = list(it_name_re.finditer(js_text))
    if not matches:
        return
    for i, m in enumerate(matches):
        start = m.start()
        end = matches[i + 1].start() if i + 1 < len(matches) else len(js_text)
        block = js_text[start:end]
        name = m.group("name").strip()
        yield name, block


def process_spec_file(spec_path: Path) -> List[Dict]:
    """Process a single spec file and return a list of testcase dicts.

    Each `it()` with at least one selector yields one testcase entry. The
    component is inferred from the spec file's parent directory name.
    """
    try:
        text = spec_path.read_text(encoding="utf-8")
    except Exception as exc:
        logger.warning("Could not read %s: %s", spec_path, exc)
        return []

    entries: List[Dict] = []
    component = spec_path.parent.name

    for it_name, block in _find_it_blocks(text):
        selectors = extract_selectors_from_js(block)
        if not selectors:
            # Skip tests without UI selectors
            continue
        selector = selectors[0]
        ui_element = infer_ui_element(selector)
        execution_time, last_result, flaky = generate_synthetic_results()

        entries.append(
            {
                "name": it_name,
                "component": component,
                "ui_element": ui_element,
                "selector": selector,
                "execution_time": execution_time,
                "last_result": last_result,
                "flaky": flaky,
            }
        )

    return entries


def scan_cypress_folder(root: Path) -> List[Dict]:
    """Scan `root` for Cypress spec files and return collected test entries.

    This function searches for files matching:
    - *.cy.js or *.cy.ts in cypress/e2e/
    - *.spec.js or *.spec.ts in cypress/tests/
    
    It is modular so you can reuse it for larger suites.
    """
    collected: List[Dict] = []

    # Look for .cy.js/.cy.ts in cypress/e2e/
    for p in root.rglob("*.cy.js"):
        parts = [part.lower() for part in p.parts]
        if "cypress" in parts and "e2e" in parts:
            logger.debug("Processing spec: %s", p)
            collected.extend(process_spec_file(p))
    
    # Also look for .cy.ts in cypress/e2e/
    for p in root.rglob("*.cy.ts"):
        parts = [part.lower() for part in p.parts]
        if "cypress" in parts and "e2e" in parts:
            logger.debug("Processing spec: %s", p)
            collected.extend(process_spec_file(p))
    
    # Look for .spec.ts/.spec.js in cypress/tests/
    for p in root.rglob("*.spec.ts"):
        parts = [part.lower() for part in p.parts]
        if "cypress" in parts and "tests" in parts:
            logger.debug("Processing spec: %s", p)
            collected.extend(process_spec_file(p))
    
    for p in root.rglob("*.spec.js"):
        parts = [part.lower() for part in p.parts]
        if "cypress" in parts and "tests" in parts:
            logger.debug("Processing spec: %s", p)
            collected.extend(process_spec_file(p))

    return collected


def write_small_testcases(testcases: List[Dict], out_path: Path) -> None:
    """Write the small_testcases.json file (creates parent dirs if needed)."""
    out_path.parent.mkdir(parents=True, exist_ok=True)
    # Assign stable incremental IDs
    for i, tc in enumerate(testcases, start=1):
        tc["id"] = i
    with out_path.open("w", encoding="utf-8") as f:
        json.dump(testcases, f, indent=2)
    logger.info("Wrote %d testcases to %s", len(testcases), out_path)


# ----------------------------- Public API ---------------------------------

def generate_small_testcases(
    project_root: Path, out_path: Optional[Path] = None
) -> Path:
    """Top-level convenience function to generate `data/small_testcases.json`.

    Returns the path to the written file.
    """
    if out_path is None:
        out_path = project_root / "data" / "small_testcases.json"

    tests = scan_cypress_folder(project_root)
    # Skip if nothing found
    if not tests:
        logger.info("No Cypress tests with selectors were found under %s", project_root)
    write_small_testcases(tests, out_path)
    return out_path


def build_cli() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(
        description="Extract lightweight Cypress testcase metadata for prioritisation"
    )
    p.add_argument(
        "root",
        nargs="?",
        default=".",
        help="Project root path that contains the cypress folder (default: current dir)",
    )
    p.add_argument(
        "--out",
        default=None,
        help="Output JSON path (default: data/small_testcases.json under project root)",
    )
    return p


def main(argv: Optional[List[str]] = None) -> int:
    parser = build_cli()
    args = parser.parse_args(argv)
    project_root = Path(args.root).resolve()
    out_path = Path(args.out) if args.out else None
    if out_path:
        out_path = out_path.resolve()

    logger.info("Scanning project root: %s", project_root)
    generate_small_testcases(project_root, out_path)
    return 0


# NOTE: The script includes a runnable `main()` but does not execute it
# automatically on import. To run, execute the script directly, e.g.:
# python tools/extract_cypress_tests.py D:/path/to/project

